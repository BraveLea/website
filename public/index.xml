<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux内核之旅</title>
    <link>https://example.org/</link>
    <description>Recent content on Linux内核之旅</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 10 Apr 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://example.org/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>“tcp丢包分析”实验解析(一)--proc文件系统</title>
      <link>https://example.org/blog/2020/04/10/tcp%E4%B8%A2%E5%8C%85%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E8%A7%A3%E6%9E%90%E4%B8%80-proc%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://example.org/blog/2020/04/10/tcp%E4%B8%A2%E5%8C%85%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E8%A7%A3%E6%9E%90%E4%B8%80-proc%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid>
      <description>tcp丢包分析系列文章代码来自谢宝友老师，由西邮陈莉君教授研一学生进行解析，本文由戴君毅整理，梁金荣编辑,贺东升校对。
 最初开发 /proc 文件系统是为了提供有关系统中进程的信息。但是这个文件系统非常有用， /proc 文件系统包含了一些目录（用作组织信息的方式）和虚拟文件。虚拟文件可以向用户呈现内核中的一些信息，也可以用作一种从用户空间向内核发送信息的手段。
/proc文件系统可以为提供很多信息， 在左边是一系列数字编号，每个实际上都是一个目录，表示系统中的一个进程。由于在Linux中创建的第一个进程是 init 进程，因此它的 process-id 为 1。
右边的目录包含特定信息，比如cpuinfo包含了CPU的信息，modules包含了内核模块的信息。
为了解决一些实际问题，我们需要在/proc下创建条目捕获信息，使用文件系统通用方法肯定是不行的，需要使用相关API编写内核模块来实现。
在做谢宝友老师写的“TCP丢包分析”实验里，首先就会在/proc下创建条目，较为简单，先来看init和exit：
static int drop_packet_init(void){int ret;struct proc_dir_entry *pe;proc_mkdir(&amp;#34;mooc&amp;#34;, NULL);proc_mkdir(&amp;#34;mooc/net&amp;#34;, NULL);ret = -ENOMEM;pe = proc_create(&amp;#34;mooc/net/drop-packet&amp;#34;,S_IFREG | 0644,NULL,&amp;amp;drop_packet_fops);if (!pe)goto err_proc;printk(&amp;#34;drop-packet loaded.\n&amp;#34;);return 0;err_proc:return ret;}static void drop_packet_exit(void){remove_proc_entry(&amp;#34;mooc/net/drop-packet&amp;#34;, NULL);remove_proc_entry(&amp;#34;mooc/net&amp;#34;, NULL);remove_proc_entry(&amp;#34;mooc&amp;#34;, NULL);printk(&amp;#34;drop-packet unloaded.\n&amp;#34;);}框架还是比较清晰的，需要深入源码来感受一下，第一部分代码：
*struct proc_dir_entry pe;</description>
    </item>
    
    <item>
      <title>“tcp丢包分析”实验解析(二)--kprobe和tracepoint</title>
      <link>https://example.org/blog/2020/04/10/tcp%E4%B8%A2%E5%8C%85%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E8%A7%A3%E6%9E%90%E4%BA%8C-kprobe%E5%92%8Ctracepoint/</link>
      <pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://example.org/blog/2020/04/10/tcp%E4%B8%A2%E5%8C%85%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E8%A7%A3%E6%9E%90%E4%BA%8C-kprobe%E5%92%8Ctracepoint/</guid>
      <description>tcp丢包分析系列文章代码来自谢宝友老师，由西邮陈莉君教授研一学生进行解析，本文由戴君毅整理，梁金荣编辑，贺东升校对。
 继续顺下实验代码，前面说过，我们需要为我们（在proc文件系统中）加入的条目编写操作集接口：
const struct file_operations drop_packet_fops = {.open = drop_packet_open,.read = seq_read,.llseek = seq_lseek,.write = drop_packet_write,.release = single_release,};实验的运行逻辑重点落在了write操作的实现中：
static ssize_t drop_packet_write(struct file *file,const char __user *buf, size_t count, loff_t *offs){int ret;char cmd[255];char chr[255];if (count &amp;lt; 1 || *offs)return -EINVAL;if (copy_from_user(chr, buf, 255))return -EFAULT;ret = sscanf(chr, &amp;#34;%255s&amp;#34;, cmd);if (ret &amp;lt;= 0)return -EINVAL;if (strcmp(cmd, &amp;#34;activate&amp;#34;) == 0) {if (!</description>
    </item>
    
    <item>
      <title>GitHub</title>
      <link>https://example.org/faq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.org/faq/</guid>
      <description>Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Vestibulum tortor quam, feugiat vitae, ultricies eget, tempor sit amet, ante. Donec eu libero sit amet quam egestas semper. Aenean ultricies mi vitae est. Mauris placerat eleifend leo.
1. WHAT TO DO IF I HAVE STILL NOT RECEIVED THE ORDER? Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Vestibulum tortor quam, feugiat vitae, ultricies eget, tempor sit amet, ante.</description>
    </item>
    
    <item>
      <title>关于</title>
      <link>https://example.org/contact/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.org/contact/</guid>
      <description>关于Linux内核之旅社区 Linux内核之旅社区是由西邮陈莉君教授创建，我们致力于传播开源文化，教授Linux内核知识。目前我们有五大平台，包括Linux内核之旅网站、GitHub、微信公众号“Linux内核之旅”、学堂在线mooc和bilibili内核视频站。
也许在我们的课程里，就有下一站的方向。 愿你活出自己想要的模样，永远保持骄傲。 &amp;ndash;陈莉君教授
我们的目标  开源文化传播 内核知识教学 Linux知识传播  我们的平台  linuxkerneltravel公众号平台：传播媒介   定期推送linux内核相关的文章 大家的成果展示平台  linuxkerneltravel网站：文章内容输出平台   社区内容承输出点 学习周报 文章翻译  linuxkerneltravel的github社区：协作平台   社区&amp;amp;网站代码协作平台 文章&amp;amp;代码&amp;amp;项目开发协作平台  学堂在线mooc：内核课程输出平台   内核知识教学 讨论区答疑  bilibili视频网站：管理内核学习视频   分享内核知识 管理大家平时录制的内核学习视频  社区委员会 联系方式 邮箱：liangjinrong111@163.com
微信公众号：Linux内核之旅</description>
    </item>
    
  </channel>
</rss>